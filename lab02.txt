Juan Zamudio
Rosario Huamani Carpio
January 31st, 2018
Lab02: Debugger

Problem 1
-------------------------------------------------------------------------------------------------

1)
  If we go past the breakpoint, we get a Segmentation Fault (Signal SIGSEGV).

2)
  The file is problem1.c and the line number is 17.

3)
  No we can't see the value that is passed because it was optimized out
  (nptr = <optimized out>).

4)
  0x0 - Null Pointer

5)
  -1835 ([Inferior 1 (process 10269) exited normally])

6)
  argc = 2
  argv[] = [0x7fffffffec33 "/home/jzamudio/Desktop/CS105/Debugger/problem1",
    0x7fffffffec62 "5"]

  The elements of argv[] came from the commands that were passed on the command
  line. The first element is the program name (given by program path) and the
  second element came from the argument passed to run, which was 5. Thus, that
  is why argc has a value of 2.

7)
  We wind up in problem1.c, line 5, in the loop_while function.

8)
  We see the lines of problem1.c up until line 10:

        1	#include <stdio.h>
        2
        3	int loop_while(int a, int b)
        4	{
        5	    int i = 0;
        6	    int result = a;
        7	    while (i < 256) {
        8		result += a;
        9		a -= b;
        10		i += b;

  After hitting the return key, we see the following lines of the program:

        11	    }
        12	    return result;
        13	}
        14
        15	int main(int argc, char *argv[])
        16	{
        17	    printf("%d\n", loop_while(atoi(argv[1]), 16));
        18	    return 0;
        19	}

9)
  The return key runs the program step by step like an instruction counter.

10)
  a = 5
  b = 16
  result = 32767

11)
  Lines 6, 5, 8, 9:

        6 - int result = a;
        5	- int i = 0;
        8	- result += a;
        9	- a -= b;

  The debugger is showing us these lines in this order because the compiler is
  reorganizing the lines for optimization, so they're not in the same order as
  the source code, although switching the order of lines 5 and 6 actually
  doesn't matter.

12)
  atoi: 0x4004ba
  printf: 0x4004e7

13)
  There is no call to loop_while.

14)
  a) print/x 42 prints the hexadecimal number from a decimal number 42 (print/x 42 = 0x2a)
	b) p 0x2f prints the decimal number 47 from a hexadecimal number 0x2f (p 0x2f = 47)

15)
  The constant in the sub comes from the int value of parameter b, which is 16

16)
  Since main was optimized, the call to loop_while happens inside the main function.


Problem 2
------------------------------------------------------------------------------------------------

1)
  $1 = 1078530011

2)
  $2 = 0x40490fdb - it could be more edifying because it's the integer from above but as
  a hexadecimal value but it could tell us something.

3)
  0x601060 <puzzle1>:	0xdb	0x0f	0x49	0x40:

  The output is the result of (2) split into its four different byte components. 
  In other words, the output is the result of splitting 0x40490fdb into four byte segments.
  What is interesting is that the result of 'x/4bx &puzzle1' is the hex digit value from (2)
  but in reverse order. So, the int from (1) is stored in memory from least signifcant bytes
  to most signifcant bytes.

4)
  